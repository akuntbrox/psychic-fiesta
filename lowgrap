-- Low Graphics ONLY — with Non-Player Animation Block (pets/NPCs/props)

-- ===== CONFIG =====
local CONFIG = {
	ButtonSizePx   = 64,
	DisplayOrder   = 2000,
	SnapMarginPx   = 12,
	StartCorner    = "bottom-right",
	RememberThisSession = true,

	DisableTextures           = true,  -- hide Decals/Textures
	HideSurfaceAppearance     = false, -- set SA maps to "" (optional, heavier)
	DisableNonPlayerAnimations = true, -- stop pets/NPC/object animations while low mode is ON
}

-- ===== Services =====
local Players      = game:GetService("Players")
local Lighting     = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local UserInput    = game:GetService("UserInputService")

local player       = Players.LocalPlayer
local PlayerGui    = player:WaitForChild("PlayerGui")
local Terrain      = workspace:FindFirstChildOfClass("Terrain")

-- ===== Safe get/set =====
local function g(inst, prop) local ok,v=pcall(function() return inst[prop] end); return ok and v or nil end
local function s(inst, prop, val) pcall(function() inst[prop]=val end) end

-- ===== Snapshot =====
local lightingProps = {
	"GlobalShadows","EnvironmentSpecularScale","EnvironmentDiffuseScale","Brightness",
	"Ambient","OutdoorAmbient","FogStart","FogEnd","FogColor","ClockTime","ShadowSoftness","Technology"
}
local terrainProps  = {
	"Decoration","WaterWaveSize","WaterWaveSpeed","WaterReflectance","WaterTransparency","WaterColor"
}

local original = {
	lighting = {},
	terrain  = {},
	postFX   = {},     -- PostEffect.Enabled
	atmo     = nil,    -- Atmosphere + props
	decals   = {},     -- Decal.Transparency
	textures = {},     -- Texture.Transparency
	surfaceA = {},     -- SurfaceAppearance maps (optional)
}
for _,p in ipairs(lightingProps) do original.lighting[p]=g(Lighting,p) end
for _,fx in ipairs(Lighting:GetDescendants()) do
	if fx:IsA("PostEffect") then original.postFX[fx]=fx.Enabled end
end
do
	local A = Lighting:FindFirstChildOfClass("Atmosphere")
	if A then
		original.atmo = { obj=A, props={
			Density=g(A,"Density"), Offset=g(A,"Offset"), Color=g(A,"Color"),
			Decay=g(A,"Decay"), Glare=g(A,"Glare"), Haze=g(A,"Haze"),
			MieScatteringScale=g(A,"MieScatteringScale"),
		}}
	end
end
if Terrain then for _,p in ipairs(terrainProps) do original.terrain[p]=g(Terrain,p) end end

-- pre-scan textures (so we can restore)
local function snapshotVisuals()
	if CONFIG.DisableTextures then
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("Decal") then if original.decals[obj]==nil then original.decals[obj]=g(obj,"Transparency") end
			elseif obj:IsA("Texture") then if original.textures[obj]==nil then original.textures[obj]=g(obj,"Transparency") end
			end
		end
	end
	if CONFIG.HideSurfaceAppearance then
		for _,obj in ipairs(workspace:GetDescendants()) do
			if obj:IsA("SurfaceAppearance") and original.surfaceA[obj]==nil then
				original.surfaceA[obj] = {
					ColorMap=g(obj,"ColorMap"), MetalnessMap=g(obj,"MetalnessMap"),
					NormalMap=g(obj,"NormalMap"), RoughnessMap=g(obj,"RoughnessMap")
				}
			end
		end
	end
end
snapshotVisuals()

-- ===== Animation blocker (non-player rigs) =====
local animBlockConns = {}  -- Animator -> RBXScriptConnection
local function isLocalCharacterHumanoid(hum)
	local char = player.Character
	return char and hum and hum:IsDescendantOf(char)
end

local function stopAnimator(animator)
	-- stop current tracks
	for _,track in ipairs(animator:GetPlayingAnimationTracks()) do
		pcall(function() track:Stop(0) end)
	end
	-- block future tracks
	if not animBlockConns[animator] then
		animBlockConns[animator] = animator.AnimationPlayed:Connect(function(track)
			pcall(function() track:Stop(0) end)
		end)
	end
end

local function applyAnimationBlock()
	for _,obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Humanoid") then
			if not isLocalCharacterHumanoid(obj) then
				local animator = obj:FindFirstChildOfClass("Animator")
				if animator then stopAnimator(animator) end
			end
		elseif obj:IsA("AnimationController") then
			local animator = obj:FindFirstChildOfClass("Animator")
			if animator then stopAnimator(animator) end
		end
	end
	-- also block any animators that appear later (pets spawned on the fly)
	workspace.DescendantAdded:Connect(function(obj)
		if obj:IsA("Animator") and CONFIG.DisableNonPlayerAnimations then
			-- avoid blocking the local player's animator
			local hum = obj.Parent and obj.Parent:FindFirstChildOfClass("Humanoid")
			if hum and isLocalCharacterHumanoid(hum) then return end
			stopAnimator(obj)
		end
	end)
end

local function clearAnimationBlock()
	for anim,conn in pairs(animBlockConns) do
		if conn then conn:Disconnect() end
		animBlockConns[anim] = nil
	end
	-- Already-stopped animations will not auto-resume (Roblox doesn’t expose rewind).
end

-- ===== Low toggle =====
local lowActive = false

local function applyLow()
	-- Lighting flatten
	s(Lighting,"GlobalShadows",false)
	s(Lighting,"EnvironmentSpecularScale",0)
	s(Lighting,"EnvironmentDiffuseScale",0)
	s(Lighting,"ShadowSoftness",0)
	s(Lighting,"Brightness",math.clamp((g(Lighting,"Brightness") or 2)*0.85,0.5,3))
	s(Lighting,"Ambient",Color3.new(0,0,0))
	s(Lighting,"OutdoorAmbient",Color3.new(0,0,0))
	for fx in pairs(original.postFX) do if fx and fx.Parent then s(fx,"Enabled",false) end end
	if original.atmo and original.atmo.obj then
		local A=original.atmo.obj
		s(A,"Density",0); s(A,"Glare",0); s(A,"Haze",0); s(A,"MieScatteringScale",0)
	end

	-- Terrain / water animation off
	if Terrain then
		s(Terrain,"Decoration",false)
		s(Terrain,"WaterWaveSize",0); s(Terrain,"WaterWaveSpeed",0)
		s(Terrain,"WaterReflectance",0); s(Terrain,"WaterTransparency",0.95)
	end

	-- Hide textures/decals
	if CONFIG.DisableTextures then
		for obj in pairs(original.decals)   do if obj and obj.Parent then s(obj,"Transparency",1) end end
		for obj in pairs(original.textures) do if obj and obj.Parent then s(obj,"Transparency",1) end end
	end
	if CONFIG.HideSurfaceAppearance then
		for obj in pairs(original.surfaceA) do
			if obj and obj.Parent then
				s(obj,"ColorMap",""); s(obj,"MetalnessMap",""); s(obj,"NormalMap",""); s(obj,"RoughnessMap","")
			end
		end
	end

	-- Block non-player animations (pets/NPC/props)
	if CONFIG.DisableNonPlayerAnimations then
		applyAnimationBlock()
	end

	lowActive = true
end

local function restoreLow()
	-- Lighting restore
	for p,v in pairs(original.lighting) do s(Lighting,p,v) end
	for fx,was in pairs(original.postFX) do if fx and fx.Parent then s(fx,"Enabled",was) end end
	if original.atmo and original.atmo.obj and original.atmo.props then
		for p,v in pairs(original.atmo.props) do s(original.atmo.obj,p,v) end
	end

	-- Terrain restore
	if Terrain then for p,v in pairs(original.terrain) do s(Terrain,p,v) end end

	-- Visuals restore
	if CONFIG.DisableTextures then
		for obj,prev in pairs(original.decals)   do if obj and obj.Parent then s(obj,"Transparency",prev) end end
		for obj,prev in pairs(original.textures) do if obj and obj.Parent then s(obj,"Transparency",prev) end end
	end
	if CONFIG.HideSurfaceAppearance then
		for obj,props in pairs(original.surfaceA) do
			if obj and obj.Parent then for k,v in pairs(props) do s(obj,k,v) end end
		end
	end

	-- Unblock animations (new ones will play normally again)
	clearAnimationBlock()

	lowActive = false
end

local function toggleLow()
	if lowActive then restoreLow() else applyLow() end
end

-- ===== Floating draggable button (edge-snap) =====
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "LowGraphicsOnlyUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.DisplayOrder = CONFIG.DisplayOrder
ScreenGui.Parent = PlayerGui

local Holder = Instance.new("Frame")
Holder.Name = "FloatHolder"
Holder.Size = UDim2.fromOffset(CONFIG.ButtonSizePx, CONFIG.ButtonSizePx)
Holder.BackgroundTransparency = 1
Holder.Active = true
Holder.Parent = ScreenGui

local anchors = {
	["bottom-right"] = {anchor = Vector2.new(1,1), pos = UDim2.new(1,-20, 1,-20)},
	["bottom-left"]  = {anchor = Vector2.new(0,1), pos = UDim2.new(0, 20, 1,-20)},
	["top-right"]    = {anchor = Vector2.new(1,0), pos = UDim2.new(1,-20, 0, 20)},
	["top-left"]     = {anchor = Vector2.new(0,0), pos = UDim2.new(0, 20, 0, 20)},
}
local a = anchors[string.lower("bottom-right")] or anchors["bottom-right"]
Holder.AnchorPoint = a.anchor
Holder.Position    = a.pos

local Button = Instance.new("TextButton")
Button.Size = UDim2.fromScale(1,1)
Button.BackgroundColor3 = Color3.fromRGB(100, 20, 20)
Button.Text = "LOW"
Button.TextScaled = true
Button.Font = Enum.Font.GothamBold
Button.TextColor3 = Color3.new(1,1,1)
Button.AutoButtonColor = true
Button.Parent = Holder

local Corner = Instance.new("UICorner")
Corner.CornerRadius = UDim.new(1, 0)
Corner.Parent = Button

local function updateButton()
	Button.Text = lowActive and "ON" or "LOW"
	Button.BackgroundColor3 = lowActive and Color3.fromRGB(20,120,20) or Color3.fromRGB(100,20,20)
end
updateButton()

Button.MouseButton1Click:Connect(function()
	if Holder:GetAttribute("DragJustEnded") then
		Holder:SetAttribute("DragJustEnded", nil)
		return
	end
	toggleLow()
	updateButton()
end)

-- Drag + edge snap
local dragging, dragInput, startMousePos
local function viewport()
	local cam = workspace.CurrentCamera
	return cam and cam.ViewportSize or Vector2.new(1920,1080)
end
local function clampTopLeft(absTopLeft, size)
	local vp = viewport()
	return Vector2.new(
		math.clamp(absTopLeft.X, 0, math.max(0, vp.X - size.X)),
		math.clamp(absTopLeft.Y, 0, math.max(0, vp.Y - size.Y))
	)
end
local function toUDim2FromPixels(px, anchor)
	local vp = viewport()
	return UDim2.new(px.X / vp.X, 0, px.Y / vp.Y, 0)
end
local function snapToEdge()
	local vp = viewport()
	local size = Holder.AbsoluteSize
	local center = Holder.AbsolutePosition + size * Holder.AnchorPoint

	local left, right = center.X, vp.X - center.X
	local top, bottom = center.Y, vp.Y - center.Y
	local margin = CONFIG.SnapMarginPx

	local minDist = math.min(left, right, top, bottom)
	local goalPos
	if minDist == left then
		goalPos = Vector2.new(margin + size.X * Holder.AnchorPoint.X, center.Y)
	elseif minDist == right then
		goalPos = Vector2.new(vp.X - margin - size.X * (1 - Holder.AnchorPoint.X), center.Y)
	elseif minDist == top then
		goalPos = Vector2.new(center.X, margin + size.Y * Holder.AnchorPoint.Y)
	else
		goalPos = Vector2.new(center.X, vp.Y - margin - size.Y * (1 - Holder.AnchorPoint.Y))
	end

	local goal = { Position = toUDim2FromPixels(goalPos, Holder.AnchorPoint) }
	TweenService:Create(Holder, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), goal):Play()

	if CONFIG.RememberThisSession then
		player:SetAttribute("LowOnly_PosX", goal.Position.X.Scale)
		player:SetAttribute("LowOnly_PosY", goal.Position.Y.Scale)
	end
end
local function beginDrag(input)
	dragging = true; dragInput = input; startMousePos = input.Position
end
local function endDrag()
	if dragging then
		dragging=false
		Holder:SetAttribute("DragJustEnded", true)
		task.delay(0.05,function() Holder:SetAttribute("DragJustEnded", nil) end)
		snapToEdge()
	end
end
Holder.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1
	or input.UserInputType == Enum.UserInputType.Touch then
		beginDrag(input)
	end
end)
Holder.InputEnded:Connect(function(input) if input == dragInput then endDrag() end end)
UserInput.InputChanged:Connect(function(input)
	if not dragging then return end
	if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end

	local delta = input.Position - startMousePos
	local startCenter = Holder.AbsolutePosition + Holder.AbsoluteSize * Holder.AnchorPoint
	local newCenter = startCenter + Vector2.new(delta.X, delta.Y)

	local half = Holder.AbsoluteSize * 0.5
	local clampedTopLeft = clampTopLeft(newCenter - half, Holder.AbsoluteSize)
	local clampedCenter = clampedTopLeft + half
	Holder.Position = toUDim2FromPixels(clampedCenter, Holder.AnchorPoint)
end)

-- Restore last position this session
if CONFIG.RememberThisSession then
	local x = player:GetAttribute("LowOnly_PosX")
	local y = player:GetAttribute("LowOnly_PosY")
	if typeof(x) == "number" and typeof(y) == "number" then
		Holder.Position = UDim2.new(x, 0, y, 0)
	end
end

-- Keep inside viewport on resize
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	task.defer(function()
		local cam = workspace.CurrentCamera
		if not cam then return end
		cam:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			local topLeft = clampTopLeft(Holder.AbsolutePosition, Holder.AbsoluteSize)
			local center = topLeft + Holder.AbsoluteSize * Holder.AnchorPoint
			Holder.Position = toUDim2FromPixels(center, Holder.AnchorPoint)
		end)
	end)
end)
